{"version":3,"sources":["utils/data_manager.js","app_utils.js","utils/event_manager.js"],"names":["data_manager","prototype","request","async","options","url","environment","api_server_url","method","mode","cache","credentials","headers","Content-Type","redirect","referrer","body","code","api_code","lang","db_name","api_db_name","fetch","JSON","stringify","then","response","ok","console","warn","Error","statusText","json","result","catch","error","msg","message","window","data_manager_alias","event_manager","this","events","last_token","subscribe","event_name","callback","token","String","new_event","push","unsubscribe","event_token","map","current_event","key","splice","publish","data","current_events","filter","get_events","fire_event","node","eventName","doc","ownerDocument","nodeType","id","dispatchEvent","eventClass","bubbles","event","createEvent","initEvent","synthetic","fireEvent","createEventObject","when_in_dom","observer","MutationObserver","mutations","document","contains","disconnect","observe","attributes","childList","characterData","subtree"],"mappings":"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","sourcesContent":["/*global get_label, environment, SHOW_DEBUG */\n/*eslint no-undef: \"error\"*/\n\n\n\n/**\n* DATA_LOADER\n*/\nexport const data_manager = function() {\n\n}//end data_manager\n\n\n\n/**\n* REQUEST\n* Make a fetch request to server api\n* @param object options\n* @return promise api_response\n*/\ndata_manager.prototype.request = async function(options) {\n\n\t// console.log(\"++++ request options:\",options);\n\n\tconst url\t\t\t= options.url || environment.api_server_url\n\tconst method\t\t= options.method || 'POST' // *GET, POST, PUT, DELETE, etc.\n\tconst mode\t\t\t= options.mode || 'cors' // no-cors, cors, *same-origin\n\tconst cache\t\t\t= options.cache || 'no-cache' // *default, no-cache, reload, force-cache, only-if-cached\n\tconst credentials\t= options.credentials || 'same-origin' // include, *same-origin, omit\n\tconst headers\t\t= options.headers || {'Content-Type': 'application/json'}// 'Content-Type': 'application/x-www-form-urlencoded'\n\tconst redirect\t\t= options.redirect || 'follow' // manual, *follow, error\n\tconst referrer\t\t= options.referrer || 'no-referrer' // no-referrer, *client\n\tconst body\t\t\t= options.body // body data type must match \"Content-Type\" header\n\n\t// code defaults\n\t\tif (!body.code) {\n\t\t\tbody.code = environment.api_code\n\t\t}\n\t// lang defaults\n\t\tif (!body.lang) {\n\t\t\tbody.lang = environment.lang\n\t\t}\n\t// db_name defaults\n\t\tif (!body.db_name && environment.api_db_name) {\n\t\t\tbody.db_name = environment.api_db_name\n\t\t}\n\n\tconst handle_errors = function(response) {\n\t\tif (!response.ok) {\n\t\t\tconsole.warn(\"-> handle_errors response:\",response);\n\t\t\tthrow Error(response.statusText);\n\t\t}\n\t\treturn response;\n\t}\n\n \tconst api_response = fetch(\n \t\turl,\n \t\t{\n\t\t\tmethod\t\t: method,\n\t\t\tmode\t\t: mode,\n\t\t\tcache\t\t: cache,\n\t\t\tcredentials\t: credentials,\n\t\t\theaders\t\t: headers,\n\t\t\tredirect\t: redirect,\n\t\t\treferrer\t: referrer,\n\t\t\tbody\t\t: JSON.stringify(body)\n\t\t})\n\t\t.then(handle_errors)\n\t\t.then(response => {\n\t\t\t// console.log(\"-> json response 1 ok:\",response.body);\n\t\t\tconst json_parsed = response.json().then((result)=>{\n\t\t\t\t//console.log(\"-> json result 2:\",result);\n\t\t\t\treturn result\n\t\t\t})\n\t\t\treturn json_parsed\n\t\t})// parses JSON response into native Javascript objects\n\t\t.catch(error => {\n\t\t\tconsole.error(\"!!!!! [page data_manager.request] ERROR:\", error)\n\t\t\tconsole.warn(\"body:\",body);\n\t\t\treturn {\n\t\t\t\tresult \t: false,\n\t\t\t\tmsg \t: error.message,\n\t\t\t\terror \t: error\n\t\t\t}\n\t\t});\n\n\treturn api_response\n}//end request\n\n\n\n/**\n* REQUEST\n* Make a fetch request to server api\n* @param object options\n* @return promise api_response\n*//*\ndata_manager.prototype.request = async function(options) {\n\n\tthis.url\t\t\t= options.url || DEDALO_CORE_URL + '/api/v1/json/'\n\tthis.method\t\t\t= options.method || 'POST' // *GET, POST, PUT, DELETE, etc.\n\tthis.mode\t\t\t= options.mode || 'cors' // no-cors, cors, *same-origin\n\tthis.cache\t\t\t= options.cache || 'no-cache' // *default, no-cache, reload, force-cache, only-if-cached\n\tthis.credentials\t= options.credentials || 'same-origin' // include, *same-origin, omit\n\tthis.headers\t\t= options.headers || {'Content-Type': 'application/json'}// 'Content-Type': 'application/x-www-form-urlencoded'\n\tthis.redirect\t\t= options.redirect || 'follow' // manual, *follow, error\n\tthis.referrer\t\t= options.referrer || 'no-referrer' // no-referrer, *client\n\tthis.body\t\t\t= options.body // body data type must match \"Content-Type\" header\n\n\tconst handle_errors = function(response) {\n\t\tif (!response.ok) {\n\t\t\tconsole.warn(\"-> handle_errors response:\",response);\n\t\t\tthrow Error(response.statusText);\n\t\t}\n\t\treturn response;\n\t}\n\n\tconst api_response = fetch(\n\t\tthis.url,\n\t\t{\n\t\t\tmethod\t\t: this.method,\n\t\t\tmode\t\t: this.mode,\n\t\t\tcache\t\t: this.cache,\n\t\t\tcredentials\t: this.credentials,\n\t\t\theaders\t\t: this.headers,\n\t\t\tredirect\t: this.redirect,\n\t\t\treferrer\t: this.referrer,\n\t\t\tbody\t\t: JSON.stringify(this.body)\n\t\t})\n\t\t.then(handle_errors)\n\t\t.then(response => {\n\t\t\t// console.log(\"-> json response 1 ok:\",response.body);\n\t\t\tconst json_parsed = response.json().then((result)=>{\n\t\t\t\t//console.log(\"-> json result 2:\",result);\n\t\t\t\treturn result\n\t\t\t})\n\t\t\treturn json_parsed\n\t\t})// parses JSON response into native Javascript objects\n\t\t.catch(error => {\n\t\t\tconsole.error(\"!!!!! [data_manager.request] ERROR:\", error)\n\t\t\treturn {\n\t\t\t\tresult \t: false,\n\t\t\t\tmsg \t: error.message,\n\t\t\t\terror \t: error\n\t\t\t}\n\t\t});\n\n\t// const api_response = await fetch(this.url, {\n\t// \t\tmethod\t\t: this.method,\n\t// \t\tmode\t\t: this.mode,\n\t// \t\tcache\t\t: this.cache,\n\t// \t\tcredentials\t: this.credentials,\n\t// \t\theaders\t\t: this.headers,\n\t// \t\tredirect\t: this.redirect,\n\t// \t\treferrer\t: this.referrer,\n\t// \t\tbody\t\t: JSON.stringify(this.body)\n\t// \t})\n\t// if (api_response.status >= 200 && api_response.status <= 299) {\n\t// \tconst json_response = await api_response.json();\n\t// \tconsole.log(\"json_response\", json_response);\n\t// \treturn json_response\n\t// } else {\n\t// \t// Handle errors\n\t// \tconsole.log(api_response.status, api_response.statusText);\n\t// }\n\n\treturn api_response\n}//end request\n*/\n\n\n/**\n* DOWNLOAD_URL\n* @param string url\n* @param string filename\n* Donwload url blob data and create a temporal autofired link\n*/\nexport function download_url(url, filename) {\n\tfetch(url).then(function(t) {\n\t\treturn t.blob().then((b)=>{\n\t\t\tvar a = document.createElement(\"a\");\n\t\t\ta.href = URL.createObjectURL(b);\n\t\t\ta.setAttribute(\"download\", filename);\n\t\t\ta.click();\n\t\t\ta.remove();\n\t\t}\n\t\t);\n\t});\n}//end download_url\n\n\n","/*global tstring, page_globals, SHOW_DEBUG, row_fields, common, page, forms, document, DocumentFragment, tstring, console */\n/*eslint no-undef: \"error\"*/\n/*jshint esversion: 6 */\n\n\n\n// app_utils . web application useful es6 modules compatible with old browsers (Configure CodeKit to ES6 Bundle IIFE) (!)\n\n\n\n// common web_app/utils imports\n\timport {data_manager as data_manager_alias} from 'utils/data_manager.js'\n\timport {event_manager as event_manager_alias} from 'utils/event_manager.js'\n\n\n\n// globals\n\twindow.data_manager\t\t= new data_manager_alias();\n\twindow.event_manager\t= new event_manager_alias();\n\t// window.data_manager_alias = function(){\n\t// \t\talert(\"44\");\n\t// };\n\n\n\n// setTimeout(function(){\n// \tconsole.log(\"Activated app_utils !\");\n// \tconsole.log(\"Avilable data_manager:\",data_manager);\n// \tconsole.log(\"Avilable event_manager:\",event_manager);\n// },10)\n\t\n","/**\n* EVENT_MANAGER\n* the event_manager is created by the page and used by all instances: section, section_group, compnents, etc\n* the event manager is a observable-observer pattern but we implement connection with the instances with tokens\n* the token is stored in the instances and the events is a array of objects every event is auto-explained\n* the ionstances has control to create news and detroy it.\n*\n* events format:[{\n*\t\t\t\t\tevent_name \t: the common name of the events for fired by publish/changes,\n*\t\t\t\t\ttoken \t\t: unique id stored in the instance for contol the event,\n*\t\t\t\t\tcallback \t: the function that will fired when publish/change will fired\n*\t\t\t\t}]\n*\n*/\nexport const event_manager = function(){\n\n\n\n\tthis.events = []\n\tthis.last_token = -1\n\n\n\n\t/**\n\t* SUBSCRIBE\n\t*/\n\tthis.subscribe = function(event_name, callback) {\n\n\t\t// new event. Init. Create the unique token\n\t\t\tconst token = \"event_\"+String(++this.last_token)\n\n\t\t// create the event\n\t\t\t\tconst new_event = {\n\t\t\t\t\tevent_name \t: event_name,\n\t\t\t\t\ttoken \t\t: token,\n\t\t\t\t\tcallback \t: callback\n\t\t\t\t}\n\t\t// add the event to the global events of the page\n\t\t\tthis.events.push(new_event)\n\n\t\t// return the token to save into the events_tokens propertie inside the caller instance\n\t\t\treturn token\n\t}//end subscribe\n\n\n\n\t/**\n\t* UNSUBSCRIBE\n\t*/\n\tthis.unsubscribe = function(event_token) {\n\n\t\tconst self = this\n\n\t\t// find the event in the global events and remove it\n\t\t\tconst result = self.events.map( (current_event, key, events) => {\n\t\t\t\t(current_event.token === event_token) ? events.splice(key, 1) : null\n\t\t\t})\n\n\t\t// return the new array without the events\n\t\t\treturn result\n\t}//end unsubscribe\n\n\n\n\t/**\n\t* PUBLISH\n\t* when the publish event is fired it need propagated to the suscribers events\n\t*/\n\tthis.publish = function(event_name, data={}) {\n\t\t//if(SHOW_DEBUG===true) {\n\t\t\t//console.log(\"[publish] event_name:\",event_name)\n\t\t\t//console.log(\"[publish] data:\",data)\n\t\t//}\n\n\t\t// find the events that has the same event_name for exec\n\t\tconst current_events = this.events.filter(current_event => current_event.event_name === event_name)\n\n\t\t// if don't find events don't exec\n\t\tif(!current_events){\n\t\t\treturn false\n\n\t\t}else{\n\t\t\t// exec the suscribed events callbacks\n\t\t\tconst result = current_events.map(current_event => current_event.callback(data))\n\t\t\treturn result\n\t\t}\n\t}//end publish\n\n\n\n\t/**\n\t* GET_EVENTS\n\t* @return\n\t*/\n\tthis.get_events = function() {\n\n\t\treturn this.events\n\t}//end get_events\n\n\n\n\t/**\n\t * Fire an event handler to the specified node. Event handlers can detect that the event was fired programatically\n\t * by testing for a 'synthetic=true' property on the event object\n\t * @param {HTMLNode} node The node to fire the event handler on.\n\t * @param {String} eventName The name of the event without the \"on\" (e.g., \"focus\")\n\t */\n\tthis.fire_event = function(node, eventName) {\n\t\t// Make sure we use the ownerDocument from the provided node to avoid cross-window problems\n\t\tvar doc;\n\t\tif (node.ownerDocument) {\n\t\t\tdoc = node.ownerDocument;\n\t\t} else if (node.nodeType == 9){\n\t\t\t// the node may be the document itself, nodeType 9 = DOCUMENT_NODE\n\t\t\tdoc = node;\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid node passed to fireEvent: \" + node.id);\n\t\t}\n\n\t\tif (node.dispatchEvent) {\n\t\t\t// Gecko-style approach (now the standard) takes more work\n\t\t\tvar eventClass = \"\";\n\n\t\t\t// Different events have different event classes.\n\t\t\t// If this switch statement can't map an eventName to an eventClass,\n\t\t\t// the event firing is going to fail.\n\t\t\tswitch (eventName) {\n\t\t\t\tcase \"click\": // Dispatching of 'click' appears to not work correctly in Safari. Use 'mousedown' or 'mouseup' instead.\n\t\t\t\tcase \"mousedown\":\n\t\t\t\tcase \"mouseup\":\n\t\t\t\t\teventClass = \"MouseEvents\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"focus\":\n\t\t\t\tcase \"change\":\n\t\t\t\tcase \"blur\":\n\t\t\t\tcase \"select\":\n\t\t\t\t\teventClass = \"HTMLEvents\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"fireEvent: Couldn't find an event class for event '\" + eventName + \"'.\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar event = doc.createEvent(eventClass);\n\n\t\t\tvar bubbles = eventName == \"change\" ? false : true;\n\t\t\tevent.initEvent(eventName, bubbles, true); // All events created as bubbling and cancelable.\n\n\t\t\tevent.synthetic = true; // allow detection of synthetic events\n\t\t\t// The second parameter says go ahead with the default action\n\t\t\tnode.dispatchEvent(event, true);\n\t\t} else  if (node.fireEvent) {\n\t\t\t// IE-old school style\n\t\t\tvar event = doc.createEventObject();\n\t\t\tevent.synthetic = true; // allow detection of synthetic events\n\t\t\tnode.fireEvent(\"on\" + eventName, event);\n\t\t}\n\t}//end fire_event\n\n\n\n\t/**\n\t* WHEN_IN_DOM\n\t* Exec a callback when node element is placed in the DOM (then is possible to know their size, etc.)\n\t* Useful to render leaflet maps and so forth\n\t* @return mutation observer\n\t*/\n\tthis.when_in_dom = function(node, callback) {\n\n\t\tconst observer = new MutationObserver(function(mutations) {\n\t\t\tif (document.contains(node)) {\n\t\t\t\t// console.log(\"It's in the DOM!\");\n\t\t\t\tobserver.disconnect();\n\n\t\t\t\tcallback(this)\n\t\t\t}\n\t\t});\n\n\t\tobserver.observe(document, {attributes: false, childList: true, characterData: false, subtree:true});\n\n\t\treturn observer\n\t}//end when_in_dom\n\n\n\n}//end event_manager\n\n\n"]}